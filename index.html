<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Game</title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);
            background-size: 400% 400%;
            animation: gradient 15s ease infinite;
            color: #fff;
            font-family: 'Arial', sans-serif;
            text-align: center;
        }

        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            gap: 30px;
            padding: 20px;
            box-sizing: border-box;
        }

        #main-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #sidebar {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            min-width: 140px;
        }

        #score {
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #highscores {
            font-size: 18px;
            text-align: left;
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.3);
            max-height: 200px;
            overflow-y: auto;
        }

        canvas {
            border: 3px solid #fff;
            background: #111;
            box-shadow: 0 0 20px rgba(255,255,255,0.3);
            image-rendering: pixelated;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            image-rendering: -moz-crisp-edges;
        }

        #controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            max-width: 140px;
        }

        button {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 20px;
            padding: 12px;
            min-width: 55px;
            min-height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button:hover, button:active {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        #music-toggle {
            font-size: 24px;
            padding: 15px;
        }

        #restart {
            display: none;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d);
            color: #000;
            font-weight: bold;
            font-size: 22px;
            padding: 15px 40px;
            border: none;
            border-radius: 25px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #restart:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(255,107,107,0.6);
        }

        @media (max-width: 700px) {
            #game-container {
                flex-direction: column;
                align-items: center;
                gap: 20px;
                padding: 10px;
            }

            #game {
                width: 280px;
                height: 560px;
            }

            #next {
                width: 120px;
                height: 120px;
            }

            #controls button {
                min-width: 50px;
                min-height: 50px;
                font-size: 18px;
                padding: 10px;
            }

            #score {
                font-size: 24px;
            }
        }

        @media (max-width: 400px) {
            #game {
                width: 240px;
                height: 480px;
            }

            #next {
                width: 100px;
                height: 100px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="main-section">
            <div id="score">Score: 0 | Level: 1 | Lines: 0</div>
            <canvas width="320" height="640" id="game"></canvas>
            <button id="restart">üîÑ Restart</button>
        </div>
        <div id="sidebar">
            <canvas width="160" height="160" id="next"></canvas>
            <button id="music-toggle"><i class="fas fa-music-slash"></i></button>
            <div id="controls">
                <button id="left"><i class="fas fa-arrow-left"></i></button>
                <button id="right"><i class="fas fa-arrow-right"></i></button>
                <button id="rotate"><i class="fas fa-sync-alt"></i></button>
                <button id="softdrop"><i class="fas fa-arrow-down"></i></button>
                <button id="harddrop"><i class="fas fa-angle-double-down"></i></button>
            </div>
            <div id="highscores"></div>
        </div>
    </div>
    <audio id="bgmusic" loop preload="auto">
        <!-- Add your tetris.mp3 here -->
        <source src="tetris.mp3" type="audio/mpeg">
    </audio>
    <script>
        // Tetris Game with enhanced features

        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        const tetrominoSequence = [];
        function generateSequence() {
            const sequence = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
            while (sequence.length) {
                const rand = getRandomInt(0, sequence.length - 1);
                const name = sequence.splice(rand, 1)[0];
                tetrominoSequence.push(name);
            }
        }

        const tetrominos = {
            'I': [
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ],
            'J': [
                [1, 0, 0],
                [1, 1, 1],
                [0, 0, 0]
            ],
            'L': [
                [0, 0, 1],
                [1, 1, 1],
                [0, 0, 0]
            ],
            'O': [
                [1, 1],
                [1, 1]
            ],
            'S': [
                [0, 1, 1],
                [1, 1, 0],
                [0, 0, 0]
            ],
            'Z': [
                [1, 1, 0],
                [0, 1, 1],
                [0, 0, 0]
            ],
            'T': [
                [0, 1, 0],
                [1, 1, 1],
                [0, 0, 0]
            ]
        };

        const colors = {
            'I': '#00FFFF',
            'O': '#FFFF00',
            'T': '#AA00FF',
            'S': '#00FF00',
            'Z': '#FF0000',
            'J': '#0000FF',
            'L': '#FFAA00'
        };

        function getNextTetromino() {
            if (tetrominoSequence.length === 0) {
                generateSequence();
            }
            const name = tetrominoSequence.pop();
            const matrix = tetrominos[name];
            const col = playfield[0].length / 2 - Math.ceil(matrix[0].length / 2);
            const row = name === 'I' ? -1 : -2;
            return {
                name: name,
                matrix: matrix,
                row: row,
                col: col
            };
        }

        function rotate(matrix) {
            const N = matrix.length - 1;
            const result = matrix.map((row, i) =>
                row.map((val, j) => matrix[N - j][i])
            );
            return result;
        }

        function isValidMove(matrix, cellRow, cellCol) {
            for (let row = 0; row < matrix.length; row++) {
                for (let col = 0; col < matrix[row].length; col++) {
                    if (matrix[row][col] && (
                        cellCol + col < 0 ||
                        cellCol + col >= playfield[0].length ||
                        cellRow + row >= playfield.length ||
                        (cellRow + row >= 0 && playfield[cellRow + row][cellCol + col])
                    )) {
                        return false;
                    }
                }
            }
            return true;
        }

        function placeTetromino() {
            for (let row = 0; row < tetromino.matrix.length; row++) {
                for (let col = 0; col < tetromino.matrix[row].length; col++) {
                    if (tetromino.matrix[row][col]) {
                        const pRow = tetromino.row + row;
                        if (pRow < 0) {
                            showGameOver();
                            return;
                        }
                        playfield[pRow][tetromino.col + col] = tetromino.name;
                    }
                }
            }

            let linesCleared = 0;
            for (let row = playfield.length - 1; row >= 0; ) {
                if (playfield[row].every(cell => !!cell)) {
                    for (let r = row; r >= 0; r--) {
                        for (let c = 0; c < playfield[r].length; c++) {
                            playfield[r][c] = playfield[r - 1][c];
                        }
                    }
                    linesCleared++;
                } else {
                    row--;
                }
            }

            if (linesCleared > 0) {
                score += [0, 40, 100, 300, 1200][linesCleared] * level;
                lines += linesCleared;
                if (lines >= level * 10) {
                    level++;
                    dropInterval = Math.max(100, dropInterval - 50);
                }
            }

            tetromino = nextTetromino;
            nextTetromino = getNextTetromino();
        }

        function showGameOver() {
            cancelAnimationFrame(rAF);
            gameOver = true;

            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(0,0,0,0.8)';
            context.fillRect(0, canvas.height / 2 - 60, canvas.width, 120);

            context.fillStyle = '#FFD700';
            context.font = 'bold 40px monospace';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('GAME OVER!', canvas.width / 2, canvas.height / 2);

            context.fillStyle = '#fff';
            context.font = '28px monospace';
            context.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);

            // Update high scores
            let highScores = JSON.parse(localStorage.getItem('highScores') || '[]');
            highScores.push(score);
            highScores.sort((a, b) => b - a);
            highScores = highScores.slice(0, 10);
            localStorage.setItem('highScores', JSON.stringify(highScores));

            const highscoresDiv = document.getElementById('highscores');
            highscoresDiv.innerHTML = 'üèÜ Top 10:<br>' + highScores.map((s, i) => `${i + 1}. ${s}`).join('<br>');

            document.getElementById('restart').style.display = 'block';
        }

        function restartGame() {
            for (let row = -2; row < 20; row++) {
                playfield[row] = new Array(10).fill(0);
            }
            score = 0;
            lines = 0;
            level = 1;
            dropInterval = 35;
            count = 0;
            gameOver = false;
            tetromino = getNextTetromino();
            nextTetromino = getNextTetromino();
            document.getElementById('restart').style.display = 'none';
            document.getElementById('score').innerText = 'Score: 0 | Level: 1 | Lines: 0';
            rAF = requestAnimationFrame(loop);
        }

        // Canvas setup
        const canvas = document.getElementById('game');
        const context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next');
        const nextContext = nextCanvas.getContext('2d');
        const grid = 32;
        const playfield = [];
        for (let row = -2; row < 20; row++) {
            playfield[row] = new Array(10).fill(0);
        }

        let tetromino = getNextTetromino();
        let nextTetromino = getNextTetromino();
        let rAF = null;
        let gameOver = false;
        let count = 0;
        let score = 0;
        let lines = 0;
        let level = 1;
        let dropInterval = 35;

        function draw3DBlock(x, y, color) {
            context.fillStyle = color;
            context.fillRect(x, y, grid - 1, grid - 1);

            // 3D highlight
            context.fillStyle = 'rgba(255,255,255,0.4)';
            context.fillRect(x, y, grid - 1, 3);
            context.fillRect(x, y, 3, grid - 1);

            // 3D shadow
            context.fillStyle = 'rgba(0,0,0,0.4)';
            context.fillRect(x + grid - 3, y, 3, grid - 1);
            context.fillRect(x, y + grid - 3, grid - 1, 3);
        }

        function loop() {
            rAF = requestAnimationFrame(loop);
            context.clearRect(0, 0, canvas.width, canvas.height);

            // Draw playfield
            for (let row = 0; row < 20; row++) {
                for (let col = 0; col < 10; col++) {
                    if (playfield[row][col]) {
                        const name = playfield[row][col];
                        draw3DBlock(col * grid, row * grid, colors[name]);
                    }
                }
            }

            // Auto drop
            if (tetromino) {
                if (++count > dropInterval) {
                    tetromino.row++;
                    count = 0;
                    if (!isValidMove(tetromino.matrix, tetromino.row, tetromino.col)) {
                        tetromino.row--;
                        placeTetromino();
                    }
                }

                // Draw current tetromino
                for (let row = 0; row < tetromino.matrix.length; row++) {
                    for (let col = 0; col < tetromino.matrix[row].length; col++) {
                        if (tetromino.matrix[row][col]) {
                            draw3DBlock((tetromino.col + col) * grid, (tetromino.row + row) * grid, colors[tetromino.name]);
                        }
                    }
                }
            }

            document.getElementById('score').innerText = `Score: ${score} | Level: ${level} | Lines: ${lines}`;

            // Draw next tetromino
            nextContext.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            const nextGrid = 40;
            const offsetX = (160 - nextTetromino.matrix[0].length * nextGrid) / 2;
            const offsetY = (160 - nextTetromino.matrix.length * nextGrid) / 2;
            for (let row = 0; row < nextTetromino.matrix.length; row++) {
                for (let col = 0; col < nextTetromino.matrix[row].length; col++) {
                    if (nextTetromino.matrix[row][col]) {
                        nextContext.fillStyle = colors[nextTetromino.name];
                        nextContext.fillRect(offsetX + col * nextGrid, offsetY + row * nextGrid, nextGrid - 1, nextGrid - 1);

                        // Simple 3D for next
                        nextContext.fillStyle = 'rgba(255,255,255,0.4)';
                        nextContext.fillRect(offsetX + col * nextGrid, offsetY + row * nextGrid, 2, nextGrid - 1);
                        nextContext.fillRect(offsetX + col * nextGrid, offsetY + row * nextGrid, nextGrid - 1, 2);
                    }
                }
            }
        }

        // Movement functions
        function moveLeft() {
            if (gameOver || !tetromino) return;
            const col = tetromino.col - 1;
            if (isValidMove(tetromino.matrix, tetromino.row, col)) tetromino.col = col;
        }

        function moveRight() {
            if (gameOver || !tetromino) return;
            const col = tetromino.col + 1;
            if (isValidMove(tetromino.matrix, tetromino.row, col)) tetromino.col = col;
        }

        function rotateCW() {
            if (gameOver || !tetromino) return;
            const matrix = rotate(tetromino.matrix);
            if (isValidMove(matrix, tetromino.row, tetromino.col)) tetromino.matrix = matrix;
        }

        function softDrop() {
            if (gameOver || !tetromino) return;
            const row = tetromino.row + 1;
            if (isValidMove(tetromino.matrix, row, tetromino.col)) {
                tetromino.row = row;
                score += 1;
            }
        }

        function hardDrop() {
            if (gameOver || !tetromino) return;
            let dropCount = 0;
            while (isValidMove(tetromino.matrix, tetromino.row + 1, tetromino.col)) {
                tetromino.row++;
                dropCount++;
            }
            if (dropCount > 0) {
                score += 2 * dropCount;
            }
            placeTetromino();
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (gameOver) return;
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                moveLeft();
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                moveRight();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                softDrop();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                rotateCW();
            } else if (e.code === 'Space') {
                e.preventDefault();
                hardDrop();
            }
        });

        // Button controls
        document.getElementById('left').addEventListener('click', moveLeft);
        document.getElementById('left').addEventListener('touchstart', (e) => { e.preventDefault(); moveLeft(); });

        document.getElementById('right').addEventListener('click', moveRight);
        document.getElementById('right').addEventListener('touchstart', (e) => { e.preventDefault(); moveRight(); });

        document.getElementById('rotate').addEventListener('click', rotateCW);
        document.getElementById('rotate').addEventListener('touchstart', (e) => { e.preventDefault(); rotateCW(); });

        document.getElementById('softdrop').addEventListener('click', softDrop);
        document.getElementById('softdrop').addEventListener('touchstart', (e) => { e.preventDefault(); softDrop(); });

        document.getElementById('harddrop').addEventListener('click', hardDrop);
        document.getElementById('harddrop').addEventListener('touchstart', (e) => { e.preventDefault(); hardDrop(); });

        document.getElementById('restart').addEventListener('click', restartGame);

        // Music toggle
        const music = document.getElementById('bgmusic');
        const musicIcon = document.querySelector('#music-toggle i');
        function toggleMusic() {
            if (music.paused) {
                music.play().catch(() => {});
                musicIcon.className = 'fas fa-music';
            } else {
                music.pause();
                musicIcon.className = 'fas fa-music-slash';
            }
        }
        document.getElementById('music-toggle').addEventListener('click', toggleMusic);

        // Init high scores display
        let highScoresInit = JSON.parse(localStorage.getItem('highScores') || '[]');
        highScoresInit.sort((a, b) => b - a);
        document.getElementById('highscores').innerHTML = highScoresInit.length ?
            'üèÜ Top 10:<br>' + highScoresInit.slice(0, 10).map((s, i) => `${i + 1}. ${s}`).join('<br>') : '';

        // Start game
        rAF = requestAnimationFrame(loop);
    </script>
</body>
</html>
