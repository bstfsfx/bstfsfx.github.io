<!DOCTYPE html>
<html lang="zh-Hant">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>俄羅斯方塊 - 瀏覽器版</title>
        <style>
  :root{
    --bg:#0b0f1a;
    --panel:#0f1724;
    --tile-size:28px;
    --gap:2px;
    --accent:#7dd3fc;
  }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans","Helvetica Neue",Arial;}
  body{display:flex;align-items:center;justify-content:center;background:
    linear-gradient(180deg,#030617 0%, #071028 100%); color:#e6eef8;}
  .container{display:flex;gap:24px;padding:24px;}
  .board{
    background:radial-gradient(circle at 10% 10%, rgba(255,255,255,0.02), transparent 10%), var(--panel);
    border-radius:8px;
    padding:16px;
    box-shadow: 0 6px 30px rgba(2,6,23,0.7), inset 0 1px 0 rgba(255,255,255,0.02);
  }
  canvas{display:block;background:linear-gradient(180deg,#061029,#071727);border-radius:4px}
  .side{
    width:220px;
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .card{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:12px;border-radius:8px;
    box-shadow: 0 4px 14px rgba(3,6,23,0.6);
  }
  .title{font-weight:700;margin-bottom:8px;color:var(--accent)}
  .stat{font-size:18px;}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button{
    padding:8px 12px;border-radius:6px;border:0;background:#0b1220;color:#d8eefc;cursor:pointer;
    box-shadow: 0 2px 0 rgba(0,0,0,0.4);font-weight:600;
  }
  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.04);color:#aee0f8}
  .small{font-size:13px;color:#bcdff0}
  .nextCanvas{background:linear-gradient(180deg,#081226,#091828);border-radius:6px}
  footer{margin-top:8px;font-size:12px;color:#9fcbe7;opacity:0.8}
  @media (max-width:880px){
    body{padding:12px}
    .container{flex-direction:column;align-items:center}
    .side{width:100%}
  }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="board card">
                <div style="display:flex;
                            align-items:center;
                            justify-content:space-between;
                            margin-bottom:8px">
                    <div style="font-weight:800;font-size:18px">俄羅斯方塊</div>
                    <div class="small">鍵盤：← → ↓ 空格 ↑ Z / P</div>
                </div>
                <canvas id="game" width="320" height="640"></canvas>
                <footer id="status" class="small">
                    準備中
                </footer>
            </div>
            <div class="side">
                <div class="card">
                    <div class="title">遊戲資訊</div>
                    <div class="stat">
                        分數: <span id="score">0</span>
                    </div>
                    <div class="stat">
                        等級: <span id="level">0</span>
                    </div>
                    <div class="stat">
                        清除列: <span id="lines">0</span>
                    </div>
                </div>
                <div class="card">
                    <div class="title">下一個方塊</div>
                    <canvas id="next" class="nextCanvas" width="120" height="120"></canvas>
                </div>
                <div class="card">
                    <div class="title">控制</div>
                    <div class="controls">
                        <button id="startBtn">Start</button>
                        <button id="pauseBtn" class="secondary">Pause</button>
                        <button id="resetBtn" class="secondary">Reset</button>
                    </div>
                </div>
                <div class="card">
                    <div class="title">遊戲提示</div>
                    <div class="small">消一列得 100 / 2 列 300 / 3 列 500 / 4 列 800（乘上等級+1）</div>
                </div>
            </div>
        </div>
        <script>
(() => {
  // Config
  const COLS = 10;
  const ROWS = 20;
  const BLOCK = 32; // pixel per block on canvas
  const CANVAS_WIDTH = COLS * BLOCK;
  const CANVAS_HEIGHT = ROWS * BLOCK;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;

  const nextCanvas = document.getElementById('next');
  const nctx = nextCanvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  const statusEl = document.getElementById('status');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');

  // Tetromino definitions (4x4 matrices)
  const TETROMINOES = {
    I: {
      matrix: [
        [0,0,0,0],
        [1,1,1,1],
        [0,0,0,0],
        [0,0,0,0]
      ],
      color: '#60f0ff'
    },
    J: {
      matrix:[
        [1,0,0],
        [1,1,1],
        [0,0,0]
      ],
      color: '#2f70ff'
    },
    L: {
      matrix:[
        [0,0,1],
        [1,1,1],
        [0,0,0]
      ],
      color: '#ffb14d'
    },
    O: {
      matrix:[
        [1,1],
        [1,1]
      ],
      color: '#ffec3d'
    },
    S: {
      matrix:[
        [0,1,1],
        [1,1,0],
        [0,0,0]
      ],
      color: '#5fe86a'
    },
    T: {
      matrix:[
        [0,1,0],
        [1,1,1],
        [0,0,0]
      ],
      color: '#c365ff'
    },
    Z: {
      matrix:[
        [1,1,0],
        [0,1,1],
        [0,0,0]
      ],
      color: '#ff5c6c'
    }
  };

  const bag = () => {
    // generate a shuffled bag of 7 tetromino keys
    const keys = Object.keys(TETROMINOES);
    for (let i = keys.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [keys[i], keys[j]] = [keys[j], keys[i]];
    }
    return keys;
  };

  // Board grid: 0 empty or {color}
  let grid = [];
  function resetGrid(){
    grid = Array.from({length: ROWS}, () => Array.from({length: COLS}, () => 0));
  }

  // Game state
  let current = null;
  let nextQueue = [];
  let dropCounter = 0;
  let lastTime = 0;
  let dropInterval = 1000; // ms, base
  let accumulatedLines = 0;
  let score = 0;
  let level = 0;
  let clearedLines = 0;
  let running = false;
  let paused = false;

  // Utilities
  function createPiece(typeKey){
    const template = TETROMINOES[typeKey];
    const matrix = template.matrix.map(row => row.slice());
    return {
      matrix,
      x: Math.floor((COLS - matrix[0].length) / 2),
      y: -1, // start above visible grid
      type: typeKey,
      color: template.color
    };
  }

  function rotateMatrix(m, dir = 1){
    // rotate clockwise (dir=1) or ccw (dir=-1)
    const N = m.length;
    const res = Array.from({length:N}, ()=>Array.from({length:N}, ()=>0));
    for (let y=0;y<N;y++){
      for (let x=0;x<N;x++){
        if (dir === 1) res[x][N-1-y] = m[y][x];
        else res[N-1-x][y] = m[y][x];
      }
    }
    // trim empty rows/cols if shape is smaller than square? Keep matrix size to allow simple placement.
    return res;
  }

  function collide(board, piece){
    const m = piece.matrix;
    for (let y=0;y<m.length;y++){
      for (let x=0;x<m[y].length;x++){
        if (m[y][x]){
          const bx = piece.x + x;
          const by = piece.y + y;
          if (bx < 0 || bx >= COLS || by >= ROWS) return true;
          if (by >= 0 && board[by][bx]) return true;
        }
      }
    }
    return false;
  }

  function merge(board, piece){
    const m = piece.matrix;
    for (let y=0;y<m.length;y++){
      for (let x=0;x<m[y].length;x++){
        if (m[y][x]){
          const bx = piece.x + x;
          const by = piece.y + y;
          if (by >= 0 && by < ROWS && bx >= 0 && bx < COLS) board[by][bx] = piece.color;
        }
      }
    }
  }

  function clearLines(){
    let linesCleared = 0;
    outer: for (let y = ROWS-1; y>=0; y--){
      for (let x = 0; x < COLS; x++){
        if (!grid[y][x]) continue outer;
      }
      // line full
      grid.splice(y,1);
      grid.unshift(Array.from({length:COLS},()=>0));
      linesCleared++;
      y++; // recheck same index after shifting
    }
    if (linesCleared > 0){
      clearedLines += linesCleared;
      const scoring = [0,100,300,500,800]; // index by lines cleared
      score += scoring[linesCleared] * (level + 1);
      // level up per 10 lines
      level = Math.floor(clearedLines / 10);
      dropInterval = Math.max(80, 1000 - level * 80); // faster with level, min cap
      updateUI();
    }
    return linesCleared;
  }

  function spawnPiece(){
    if (nextQueue.length < 3) nextQueue.push(...bag());
    const key = nextQueue.shift();
    current = createPiece(key);
    // if immediate collision -> game over
    if (collide(grid, current)){
      running = false;
      statusEl.textContent = '遊戲結束';
    }
    updateNextCanvas();
  }

  // Wall-kick: try offsets when rotating
  function attemptRotate(dir){
    const original = current.matrix;
    const rotated = rotateMatrix(original, dir);
    const saveX = current.x;
    const kicks = [0, -1, 1, -2, 2];
    for (let k=0;k<kicks.length;k++){
      current.matrix = rotated;
      current.x = saveX + kicks[k];
      if (!collide(grid, current)){
        return true;
      }
    }
    // fail: restore
    current.matrix = original;
    current.x = saveX;
    return false;
  }

  function drop(){
    current.y++;
    if (collide(grid, current)){
      current.y--;
      merge(grid, current);
      const cleared = clearLines();
      spawnPiece();
    }
    updateUI();
  }

  function hardDrop(){
    while(true){
      current.y++;
      if (collide(grid, current)){
        current.y--;
        break;
      }
    }
    merge(grid, current);
    const cleared = clearLines();
    spawnPiece();
    updateUI();
  }

  function move(dir){
    current.x += dir;
    if (collide(grid, current)) current.x -= dir;
    updateUI();
  }

  // Rendering
  function drawCell(x, y, color){
    const pad = 2;
    ctx.fillStyle = color;
    ctx.fillRect(x*BLOCK + pad, y*BLOCK + pad, BLOCK - pad*2, BLOCK - pad*2);
    // subtle shine
    ctx.strokeStyle = "rgba(255,255,255,0.03)";
    ctx.strokeRect(x*BLOCK + pad, y*BLOCK + pad, BLOCK - pad*2, BLOCK - pad*2);
  }

  function draw(){
    // background
    ctx.clearRect(0,0, canvas.width, canvas.height);
    // draw grid background
    ctx.fillStyle = "#031026";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw placed blocks
    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        if (grid[y][x]){
          drawCell(x,y, grid[y][x]);
        } else {
          // optional subtle grid lines
          ctx.strokeStyle = 'rgba(255,255,255,0.02)';
          ctx.strokeRect(x*BLOCK+0.5, y*BLOCK+0.5, BLOCK-1, BLOCK-1);
        }
      }
    }
    // draw current piece
    if (current){
      const m = current.matrix;
      for (let y=0;y<m.length;y++){
        for (let x=0;x<m[y].length;x++){
          if (m[y][x]){
            const bx = current.x + x;
            const by = current.y + y;
            if (by >= 0){
              drawCell(bx, by, current.color);
            }
          }
        }
      }
    }
  }

  function updateNextCanvas(){
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    nctx.fillStyle = '#07182a';
    nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);

    if (!nextQueue[0]) return;
    const key = nextQueue[0];
    const tpl = TETROMINOES[key];
    const m = tpl.matrix;
    const cell = 24;
    const offsetX = Math.floor((nextCanvas.width - m[0].length * cell)/2);
    const offsetY = Math.floor((nextCanvas.height - m.length * cell)/2);

    for (let y=0;y<m.length;y++){
      for (let x=0;x<m[y].length;x++){
        if (m[y][x]){
          nctx.fillStyle = tpl.color;
          nctx.fillRect(offsetX + x*cell + 3, offsetY + y*cell + 3, cell-6, cell-6);
          nctx.strokeStyle = 'rgba(255,255,255,0.04)';
          nctx.strokeRect(offsetX + x*cell + 3, offsetY + y*cell + 3, cell-6, cell-6);
        }
      }
    }
  }

  function updateUI(){
    scoreEl.textContent = score;
    levelEl.textContent = level;
    linesEl.textContent = clearedLines;
    statusEl.textContent = running ? (paused ? "暫停" : "遊戲中") : "準備中";
  }

  // Game loop
  function update(time=0){
    if (!running || paused) {
      draw();
      requestAnimationFrame(update);
      return;
    }
    const delta = time - lastTime;
    lastTime = time;
    dropCounter += delta;
    if (dropCounter > dropInterval){
      drop();
      dropCounter = 0;
    }
    draw();
    requestAnimationFrame(update);
  }

  // Input
  document.addEventListener('keydown', e => {
    if (!running) return;
    if (e.key === 'ArrowLeft'){ e.preventDefault(); move(-1); }
    else if (e.key === 'ArrowRight'){ e.preventDefault(); move(1); }
    else if (e.key === 'ArrowDown'){ e.preventDefault(); drop(); }
    else if (e.key === ' '){ e.preventDefault(); hardDrop(); }
    else if (e.key === 'ArrowUp'){ e.preventDefault(); attemptRotate(1); }
    else if (e.key === 'z' || e.key === 'Z'){ e.preventDefault(); attemptRotate(-1); }
    else if (e.key === 'p' || e.key === 'P'){ e.preventDefault(); togglePause(); }
  });

  startBtn.addEventListener('click', () => {
    startGame();
  });
  pauseBtn.addEventListener('click', () => togglePause());
  resetBtn.addEventListener('click', () => resetGame());

  function startGame(){
    resetGrid();
    nextQueue = [];
    nextQueue.push(...bag());
    nextQueue.push(...bag());
    score = 0;
    clearedLines = 0;
    level = 0;
    dropInterval = 1000;
    running = true;
    paused = false;
    spawnPiece();
    updateUI();
    lastTime = performance.now();
    dropCounter = 0;
    requestAnimationFrame(update);
  }

  function resetGame(){
    running = false;
    paused = false;
    resetGrid();
    current = null;
    nextQueue = [];
    score = 0;
    clearedLines = 0;
    level = 0;
    updateUI();
    draw();
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    statusEl.textContent = '已重設';
  }

  function togglePause(){
    if (!running) return;
    paused = !paused;
    statusEl.textContent = paused ? '暫停' : '遊戲中';
  }

  // Initialize UI once
  resetGrid();
  draw();
  updateUI();

  // Auto-start is false. Player clicks Start.
})();
        </script>
    </body>
</html>
