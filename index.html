<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Game</title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            background: linear-gradient(-45deg, #ee7752, #e73c7e, #23abd5, #23a6d5);
            background-size: 400% 400%;
            animation: gradient 15s ease infinite;
            color: #fff;
            font-family: sans-serif;
            text-align: center;
        }

        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100%;
        }

        canvas {
            border: 1px solid white;
            background: black;
        }

        #next {
            border: 1px solid white;
            background: black;
            margin: 10px;
        }

        #score, #highscores {
            font-size: 24px;
            margin: 10px;
        }

        #controls {
            display: flex;
            justify-content: center;
            margin: 10px;
        }

        button {
            font-size: 24px;
            margin: 5px;
            padding: 10px;
            background: transparent;
            color: white;
            border: 1px solid white;
            cursor: pointer;
        }

        @media (max-width: 600px) {
            canvas {
                width: 240px;
                height: 480px;
            }

            #next {
                width: 80px;
                height: 80px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="score">Score: 0</div>
        <canvas width="320" height="640" id="game"></canvas>
        <canvas width="160" height="160" id="next"></canvas>
        <div id="highscores"></div>
        <button id="music-toggle"><i class="fas fa-music"></i></button>
        <audio id="bgmusic" loop>
            <!-- Provide your own tetris.mp3 file -->
            <source src="tetris.mp3" type="audio/mpeg">
        </audio>
        <div id="controls">
            <button id="left"><i class="fas fa-arrow-left"></i></button>
            <button id="right"><i class="fas fa-arrow-right"></i></button>
            <button id="down"><i class="fas fa-arrow-down"></i></button>
            <button id="rotate"><i class="fas fa-sync-alt"></i></button>
        </div>
    </div>
    <script>
        // Based on basic Tetris, enhanced with features

        // get a random integer
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // generate sequence
        const tetrominoSequence = [];
        function generateSequence() {
            const sequence = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
            while (sequence.length) {
                const rand = getRandomInt(0, sequence.length - 1);
                const name = sequence.splice(rand, 1)[0];
                tetrominoSequence.push(name);
            }
        }

        // get next tetromino
        const tetrominos = {
            'I': [
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ],
            'J': [
                [1, 0, 0],
                [1, 1, 1],
                [0, 0, 0],
            ],
            'L': [
                [0, 0, 1],
                [1, 1, 1],
                [0, 0, 0],
            ],
            'O': [
                [1, 1],
                [1, 1],
            ],
            'S': [
                [0, 1, 1],
                [1, 1, 0],
                [0, 0, 0],
            ],
            'Z': [
                [1, 1, 0],
                [0, 1, 1],
                [0, 0, 0],
            ],
            'T': [
                [0, 1, 0],
                [1, 1, 1],
                [0, 0, 0],
            ]
        };

        const colors = {
            'I': 'cyan',
            'O': 'yellow',
            'T': 'purple',
            'S': 'green',
            'Z': 'red',
            'J': 'blue',
            'L': 'orange'
        };

        function getNextTetromino() {
            if (tetrominoSequence.length === 0) {
                generateSequence();
            }
            const name = tetrominoSequence.pop();
            const matrix = tetrominos[name];
            const col = playfield[0].length / 2 - Math.ceil(matrix[0].length / 2);
            const row = name === 'I' ? -1 : -2;
            return {
                name: name,
                matrix: matrix,
                row: row,
                col: col
            };
        }

        // rotate matrix
        function rotate(matrix) {
            const N = matrix.length - 1;
            const result = matrix.map((row, i) =>
                row.map((val, j) => matrix[N - j][i])
            );
            return result;
        }

        // valid move
        function isValidMove(matrix, cellRow, cellCol) {
            for (let row = 0; row < matrix.length; row++) {
                for (let col = 0; col < matrix[row].length; col++) {
                    if (matrix[row][col] && (
                        cellCol + col < 0 ||
                        cellCol + col >= playfield[0].length ||
                        cellRow + row >= playfield.length ||
                        playfield[cellRow + row][cellCol + col]
                    )) {
                        return false;
                    }
                }
            }
            return true;
        }

        // place tetromino
        function placeTetromino() {
            for (let row = 0; row < tetromino.matrix.length; row++) {
                for (let col = 0; col < tetromino.matrix[row].length; col++) {
                    if (tetromino.matrix[row][col]) {
                        if (tetromino.row + row < 0) {
                            showGameOver();
                        }
                        playfield[tetromino.row + row][tetromino.col + col] = tetromino.name;
                    }
                }
            }

            // clear lines
            let linesCleared = 0;
            for (let row = playfield.length - 1; row >= 0; ) {
                if (playfield[row].every(cell => !!cell)) {
                    for (let r = row; r >= 0; r--) {
                        for (let c = 0; c < playfield[r].length; c++) {
                            playfield[r][c] = playfield[r - 1][c];
                        }
                    }
                    linesCleared++;
                } else {
                    row--;
                }
            }

            // update score
            if (linesCleared > 0) {
                score += [0, 40, 100, 300, 1200][linesCleared] * level;
                lines += linesCleared;
                if (lines >= level * 10) {
                    level++;
                    dropInterval = Math.max(100, dropInterval - 50);
                }
            }

            tetromino = nextTetromino;
            nextTetromino = getNextTetromino();
        }

        function showGameOver() {
            cancelAnimationFrame(rAF);
            gameOver = true;

            context.fillStyle = 'black';
            context.globalAlpha = 0.75;
            context.fillRect(0, canvas.height / 2 - 30, canvas.width, 60);

            context.globalAlpha = 1;
            context.fillStyle = 'white';
            context.font = '36px monospace';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('GAME OVER!', canvas.width / 2, canvas.height / 2);

            // update high scores
            let highScores = JSON.parse(localStorage.getItem('highScores') || '[]');
            highScores.push(score);
            highScores.sort((a, b) => b - a);
            highScores = highScores.slice(0, 10);
            localStorage.setItem('highScores', JSON.stringify(highScores));

            // display top 10
            const highscoresDiv = document.getElementById('highscores');
            highscoresDiv.innerHTML = 'Top 10 Scores:<br>' + highScores.map(s => s).join('<br>');
        }

        const canvas = document.getElementById('game');
        const context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next');
        const nextContext = nextCanvas.getContext('2d');
        const grid = 32;
        const playfield = [];
        for (let row = -2; row < 20; row++) {
            playfield[row] = [];
            for (let col = 0; col < 10; col++) {
                playfield[row][col] = 0;
            }
        }

        let tetromino = getNextTetromino();
        let nextTetromino = getNextTetromino();
        let rAF = null;
        let gameOver = false;
        let count = 0;
        let score = 0;
        let lines = 0;
        let level = 1;
        let dropInterval = 35; // frames per drop

        // draw 3D block
        function draw3DBlock(x, y, color) {
            context.fillStyle = color;
            context.fillRect(x, y, grid - 1, grid - 1);

            // 3D effect: light and dark borders
            context.fillStyle = 'rgba(255,255,255,0.3)'; // light top-left
            context.beginPath();
            context.moveTo(x, y);
            context.lineTo(x + grid - 1, y);
            context.lineTo(x, y + grid - 1);
            context.fill();

            context.fillStyle = 'rgba(0,0,0,0.3)'; // dark bottom-right
            context.beginPath();
            context.moveTo(x + grid - 1, y + grid - 1);
            context.lineTo(x + grid - 1, y);
            context.lineTo(x, y + grid - 1);
            context.fill();
        }

        function loop() {
            rAF = requestAnimationFrame(loop);
            context.clearRect(0, 0, canvas.width, canvas.height);

            // draw playfield
            for (let row = 0; row < 20; row++) {
                for (let col = 0; col < 10; col++) {
                    if (playfield[row][col]) {
                        const name = playfield[row][col];
                        draw3DBlock(col * grid, row * grid, colors[name]);
                    }
                }
            }

            // draw tetromino
            if (tetromino) {
                if (++count > dropInterval) {
                    tetromino.row++;
                    count = 0;
                    if (!isValidMove(tetromino.matrix, tetromino.row, tetromino.col)) {
                        tetromino.row--;
                        placeTetromino();
                    }
                }

                for (let row = 0; row < tetromino.matrix.length; row++) {
                    for (let col = 0; col < tetromino.matrix[row].length; col++) {
                        if (tetromino.matrix[row][col]) {
                            draw3DBlock((tetromino.col + col) * grid, (tetromino.row + row) * grid, colors[tetromino.name]);
                        }
                    }
                }
            }

            // update score
            document.getElementById('score').innerText = `Score: ${score} | Level: ${level} | Lines: ${lines}`;

            // draw next
            nextContext.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            const nextGrid = 40;
            for (let row = 0; row < nextTetromino.matrix.length; row++) {
                for (let col = 0; col < nextTetromino.matrix[row].length; col++) {
                    if (nextTetromino.matrix[row][col]) {
                        nextContext.fillStyle = colors[nextTetromino.name];
                        nextContext.fillRect(col * nextGrid, row * nextGrid, nextGrid-1, nextGrid-1);
                    }
                }
            }
        }

        // keyboard
        document.addEventListener('keydown', (e) => {
            if (gameOver) return;
            if (e.key === 'ArrowLeft') {
                const col = tetromino.col - 1;
                if (isValidMove(tetromino.matrix, tetromino.row, col)) tetromino.col = col;
            } else if (e.key === 'ArrowRight') {
                const col = tetromino.col + 1;
                if (isValidMove(tetromino.matrix, tetromino.row, col)) tetromino.col = col;
            } else if (e.key === 'ArrowDown') {
                const row = tetromino.row + 1;
                if (isValidMove(tetromino.matrix, row, tetromino.col)) tetromino.row = row;
            } else if (e.key === 'ArrowUp') {
                const matrix = rotate(tetromino.matrix);
                if (isValidMove(matrix, tetromino.row, tetromino.col)) tetromino.matrix = matrix;
            }
        });

        // touch buttons
        document.getElementById('left').addEventListener('touchstart', () => {
            const col = tetromino.col - 1;
            if (isValidMove(tetromino.matrix, tetromino.row, col)) tetromino.col = col;
        });
        document.getElementById('right').addEventListener('touchstart', () => {
            const col = tetromino.col + 1;
            if (isValidMove(tetromino.matrix, tetromino.row, col)) tetromino.col = col;
        });
        document.getElementById('down').addEventListener('touchstart', () => {
            const row = tetromino.row + 1;
            if (isValidMove(tetromino.matrix, row, tetromino.col)) tetromino.row = row;
        });
        document.getElementById('rotate').addEventListener('touchstart', () => {
            const matrix = rotate(tetromino.matrix);
            if (isValidMove(matrix, tetromino.row, tetromino.col)) tetromino.matrix = matrix;
        });

        // music toggle
        const music = document.getElementById('bgmusic');
        document.getElementById('music-toggle').addEventListener('click', () => {
            if (music.paused) {
                music.play();
            } else {
                music.pause();
            }
        });

        // start game
        rAF = requestAnimationFrame(loop);
    </script>
</body>
</html>
